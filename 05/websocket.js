// изначально нам, как и в случае с XMLHttpRequest нам нежно
// создать новый объект через конструктор
// но в отличии от того же XMLHttpRequest соединение устанавливаетя сразу
var socket = new WebSocket("ws://site.example.com/ws");

// после создания объекта мы получаем возожность слушать события сокета
// onopen - вызовется когда сокет открывается
socket.onopen = function() {
	console.log("Сокет открывается");
};

// onclose - когда соединение закрылось
socket.onclose = function(event) {
	// если сокет закрыт программно, чисто, то обрабатываем это как
	// нормальное (чистое) закрытие
	if (event.wasClean) {
		console.log('Соединение было закрыто');
	// конечно же, существуют ситуации, когда сокет закрывается ошибочно
	// например - программист или сисадмин 'убил' процесс с сокетом
	// или соединение разорвалось
	} else {
		console.log('Произошла ошибка соединения');
	}
};

// самый интересный для нас колбек
// как только приходит сообщение от сервера - мы тут же его принимаем
// и обрабатываем
socket.onmessage = function(event) {
	console.log("Получены данные " + event.data);
};

// самый интересный для нас метод
// он позволяет отправить серверу данные
// сервер точно так же как и клиет слушает сокет, и в случае
// поступления новых данных - обрабатывает их
socket.send(/*любые данные тут*/);

// отлов ошибок
socket.onerror = function(error) {
	console.log("Ошибка " + error.message);
};

// чтобы закрыть сокет - вызываем соответствующий метод
socket.close();

// так же
// сокетом передаются специальные коды (опкоды, - opcodes) при отправке пакетов
// которые могут уазывать на тип данных или быть сигналом к действиям
// [0x1] текстовый
// [0x2] двоичный фрейм
// [0x3..7] просто зарезервированы
// [0x8] закрывает соединение
// [0x9] PING
// [0xA] PONG
// [0xB..F] просто зарезервированы
// [0x0] этот ког говорит, о том, что мы передаем часть от большого пакета
// он будет продолжением ближайшего переданого такого же нулевого кода

// таким образом, мы видим, что закрыть сокет можно передав специальный код