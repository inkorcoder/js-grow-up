# SVG, Canvas, requestAnimationFrame, WebGL

## SVG
Scalable Vector Graphics - это язык, разметки масштабируемой графики. Файлы имеют одноименное расширение. Преимущество SVG в том, что при сколько угодном увеличении изображения не теряет четкости, поскольку фигура в SVG представляет собой математическую модель, описывающую ее форму, а не просто набор пикселей

### Аттрибуты
В `SVG` работа с объектами напрямую происходит через аттрибуты.

Существует много аттрибутов как для самого контейнера `SVG` так и для всех фигур внутри.

Базовымы являются `width`, `height` и `viewBox`, который описывает видимую часть композиции. Представляет из себя 4 числа:
```
<svg width="100" height="100" viewBox="0 0 100 100"></svg>
```
- `0` - верхний левый угол (X)
- `0` - верхний левый угол (Y)
- `100` - ширина видимой области
- `100` - высота видимой области

Если его значения не подогнаны под нарисованные фигуры - то они будут пропорционально уменьшаться или увеличиваться при отрисовке

> в IE для того, чтобы добиться адаптивности как с обычным <img> нужно убрать этот аттрибут

[Наглядные примеры viewBox](http://tutorials.jenkov.com/svg/svg-viewport-view-box.html)

Так же, существует ряд аттрибутов, для работы с самими фигурами

### Стилизация
Для стилизации в SVG есть заготовленные аттрибуты
- `fill` - заливка (color)
- `stroke` - цвет обводки (color)
- `stroke-width` - толщина обводки (px)
```
<path fill="#000" stroke="#f00">
```

### Самые распространенные элементы
- `line` - линия
- `rect` - прямоугольник
- `circle` - круг
- `path` - фигура, описанная командами (M,L,V,G,Q...)
- `polygon` - фигура, описанная точками (10,10 20,20 ...)
- `text` - текст
- `g` - группа

У каждого шейпа предусмотрен свой набор аттрибутов, которые есть только у него. Например шрифт можно указать только для шейпа `text`

### d=""
Самый основной аттрибут, который доступен у `path`. Он описывает путь, по которому отрисовывается фигура. Для описания используются специальные комманды:

- M - `moveto` - перенос курсора в точку
- L - `lineto` - линия
- C - `cubic curveto` - кубическая кривая Безье
- Q - `quadratic curveto` - квадратическая кривая Безье
- T - сглаженная кубическая кривая Безье
- S - сглаженная квадратическая кривая Безье
- A - `arcto` - арка, дуга
- Z - `closepath` - закрывает текущий путь (начальная + текущая точки)

### Полигон
Полигоны описываются так же как и `d=""`, за исключением того, что указываются только цифры, без флагов

[Подробно о d=""](https://developer.mozilla.org/ru/docs/Web/SVG/Attribute/d)

> Регистр не имеет значения в данном случае, однако стоит выбрать для себя единый стиль описания, чтобы не путать себя и других

### События
В `SVG` все фигуры являются реальными нодами, это позволяет нам выбирать их и слушать события так же само, как и на любом другом элементе
```
document.querySelector('svg path').addEventListener((e) => {
	console.log(this)
});
```

### Транформации
В атрибуте transform перечисляются описания преобразований, применяемых как к самому элементу, так и к его последователям. 

```
<svg>
	<path transform="translate(30) rotate(45 50 50)"></path>
</svg>
```

> Вращение происходит не как в CSS в центре элемента, а всегда в точке начала координат, это может сбить с толку новичка

[Подробно о транформациях](https://developer.mozilla.org/ru/docs/Web/SVG/Attribute/transform)

## Canvas
HTML5 Canvas - это технология, позволяющая отрисовать практически что угодно в виде картинки. Это технология растровой графики, и работа с ним ведется как с набором пикселей.
<br>

Все нарисованные элементы не являются нодами как в случае с SVG, и работа с ними ведется только используя оперативную память, поэтому он отрисовывается практически мгновенно.
<br>

Так как объекты не являются нодами, мы не можем слушать их события (mouseenter, moueover, ...)

### Контекст
Для работы с `canvas` нужно получить его контекст. Это `API` для отрисовки.

```
var canvas = document.getElementById('myCanvas');
var ctx = canvas.getContext('2d');
```

### Стилизация
В `Canvas` стили навешиваются глобально. Если один раз указать обводку - она будет одинаковой для всех нарисованных фигур

Несколько свойств для стилизвции:

- `lineWidth` - толщина линии
- `strokeStyle` - цвет обводки
- `fillStyle` - цвет заливки
- `font` - параметры шрифта
- `filter` - фильтр

> Значения можно менять когда угодно, например для отрисовки разноцветных фигур. Нужно изменить значение свойства и новые фигуры будут рисоваться с новыми стилями

### Сохранение, загрузка

Канвас предоставляет API для работы с собой, его мы называем контекстом. Контекст хранит в себе состояние, которое мы можем сохранить и восстановить при необходимости

- `.save()` - сохраняет контекст
- `.restore()` - восстанавливает контекст

### Фигуры

Для отрисовки фигур существует несколько методов:

- `lineTo` - линия
- `rect` - прямоугольник (путем обводки)
- `fillRect` - прямоугольник (путем заливки)
- `arc` - дуга
- `drawImage` - рисует картинку из элемента `img`

```
ctx.drawImage(img, 0, 0);
```

### Транформации

Трансформации производятся именно с контекстом, а не с элементами. Это означает то, что повернув контекст единажды - все последужщие элементы будут рисоваться повернутыми, с учетом глоальной системы координат
<br>

### getImageData()

Мы можем получить данные из канваса путем вызова `getImageData()`. Данные вернутся в виде массива. Под каждый пиксель выделяется 4 элемента массива:

- `каждый 1й` - red (красный)
- `каждый 2й` - green (зеленый)
- `каждый 3й` - blue (синий)
- `каждый 4й` - alpha (прозрачность пиксля)

## RequestAnimationFrame
`requestAnimationFrame` - глобальная функция на объекте window, которая вызывается 60 раз в секунду (не больше), тем самым добиваясь заветных 60fps. Если система не может так быстро вызвать функцию из-за загруженности, то ее частота вызова будет варьироваться.

## WebGL
`WebGL` — это контекст элемента `canvas`, который обеспечивает API 3D графики без использования плагинов. Фактически, это спецификация `OpenGL`, которая используется для разработки 3D игр.
<br>

Результат так же рендерится внутри элемента `canvas`, но его контекст получается путем `canvas.getContext('webgl')`


## Домашнее задание
Реализовать мини-библиотеку для отрисовки графиков сначала с помощью `SVG`, а затем с помощью `canvas`.
<br>

Библиотека должна быть оформлена в класс, который должен принимать HTML-елемент, в котором нужно отрисовать график, тип графика (svg или canvas) и данные для отрисовки.
- `element` - [node] элемент, в котором отрисовываем
- `mode` - [string] тип графика (SVG или Canvas)
- `type` - [string] тип графика (`line`, `pie`)
- `options` - [object] - настройки для графика. Как минимум должна быть возможность указать цвет графика
- `data` - [json] данные для отрисовки. Не менее 5 точек. Каждая должна иметь как минимум числовое поле и подпись

Графики должны быть 3 видов:
- `line` - кривая линия, с обозначениями в виде кружочков в точках перелома
- `pie` - радиальный график

> * [задание со звездочкой] PIE - в опциях должен передаваться так же внутренний радиус. Если он будет равен `0` - график будет замкнутым, сплошным кругом. Если больше - то внутри графика будет отрисовываться пустой круг

#### Так же

- Нужно сверстать страницу, на которой будут показаны все типи графиков в две строки, в первой - SVG, во второй - canvas для сравнения результата.
- Графики должны быть адаптивными
- При наводе мышкой на точку линейного графика - должен появляться тултип с подписью и значением
- Библиотека обернута в класс, который в свою очередь должен обращаться к другим классам для конструирования графиков. То есть будет класс `SVGGraph` и `CanvasGraph`, в зависимости от переданных данных в класс `Graph` он создаст нужный екземпляр и вернет его.


[Назад](https://github.com/inkorcoder/js-grow-up)